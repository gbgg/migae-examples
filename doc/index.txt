Structure:

    1.  a.  gen-class only, no ring, no gae, test with jetty-runner
        b.  ditto, but use impl-ns to split out method implementations for interactive dev
	c.  add filter, to reload source code
    2.  ring.
        a.  show how ring clojurizes the vanilla servlet stuff
        b.  weakness of ring: only one servlet, no web.xml
    3.  gae

testing/dev:  from plain jetty-runner to interactive repl dev

jetty-runner.  See http://www.eclipse.org/jetty/documentation/current/jetty-runner.html

To make clj source files visible to jetty (so the clojure runtime can
find and evaluate them) use the --classes option to jetty-runner.jar.
E.g. from the project dir:

    $ java -jar jetty-runner.jar --classes src/ war

Try it without the --classes option and you'll get:

java.io.FileNotFoundException: Could not locate ex1b/impl__init.class or ex1b/impl.clj on classpath:

Note that it is looking for either a class file or a clj file, which
means that Clojure is in charge.

Once everything works, run lein jar to put everything (including
source) into the jar, so it will be available to the GAE servers.  For
production, you can aot compile everthing.

To see what goes in the jarfile:  $ jar tf war/WEB-INF/lib/ex1b-0.1.0.SNAPSHOT.jar

Exploring Clojure RTE:

    Try running the app without the Clojure jar in war/WEB-INF/lib -
    you'll get a message to the effect that
    "java.lang.NoClassDefFoundError: clojure/lang/IFn"...Caused by:
    java.lang.ClassNotFoundException: clojure.lang.IFn".  This means
    (I believe) that the container was able to load the
    (Clojure-generated) servlet classfile, but when it went to invoke
    its methods - e.g. init - the Clojure-generated stub
    implementation said, in effect, "find the test-init class in the
    impl package and run it".  This is a command to be handled by the
    Clojure runtime rather than the JVM, and since the runtime jar is
    missing, you get the ClassNotFound exception.

ex1:

After $ lein compile, list the contents of war/WEB-INF/classes/ex1/

-rw-r--r--  1 gar  staff   996 Aug 22 00:06 request$_service.class
-rw-r--r--  1 gar  staff  1322 Aug 22 00:06 request$fn__16.class
-rw-r--r--  1 gar  staff  1876 Aug 22 00:06 request$loading__4910__auto__.class
-rw-r--r--  1 gar  staff  6134 Aug 22 00:06 request.class
-rw-r--r--  1 gar  staff  3386 Aug 22 00:06 request__init.class

You can see that our -service function has generated
request$_service.class, and that ex1/request.clj, with namespace
ex1.request and :gen-class, has generated request.class.  What about
the other stuff here?  In particular, what is fn__16?  Must be an
anonymous function, but where did it come from?

Let's go back to gen-class.  The doc says "The gen-class construct
contains no implementation, as the implementation will be dynamically
sought by the generated class in functions in an implementing Clojure
namespace."  So any methods in the signature of the class have
corresponding functions in the Clojure ns.  In our case that means the
HttpServlet API.  At a minimum, any servlet must implement the methods
essential to the servlet life-cycle: init, service, and destroy.
We've provided Clojure implementations for all three, so fn__16 must
be some other function generated by the gen-class machinery.

Once everything is debugged, we will replace these class files by
jarring them up into a jarfile.  But for now, this is where the
servlet container will search for servlets.

Fire up dev_appserver - $GAESDK/bin/dev_appserver.sh war - and go to
http://localhost:8080/request/foo in your browser.  You should see
nothing in the browser, but on the console you should see "ex1.request
src code read and evaluated" the first time, and "ex1.request service
method invoked" every time you access the URL specified in
WEB-INF/web.xml - in this case <url-pattern>/request/*</url-pattern>

This tells you that: 1) the servlet container first locates, loads,
and initializes the servlet, which in this case is the code generated
as a result of aot-compiling code with :gen-class.

Question: why does the println statement get executed when the servlet
container starts up the servlet?  Shouldn't it just load the code
without evaluating anything?


