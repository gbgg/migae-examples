# Experiment ex0a

gen-class magic, demystified

*CAVEAT* This text has not yet been vetted by people Who Know What
 They're Talking About.  It's my best guess as to how the magic of
 Clojure works in the context of a sservlet container.  It's mostly
 correct, but there are some things I say that are based on inference
 rather than knowledge.

## Usage

Start out by using the Leiningen "jar" task:

    ex0a $ lein jar

The result should be a jarfile in war/WEB-INF/lib; that's because our
project.clj contains this clause:

	    :target-path "war/WEB-INF/lib"

Verify:

    ex0a $ ls -l war/WEB-INF/lib
    -rw-r--r--  1 <uid>  <gid>  2986 Aug 24 08:55 ex0a-0.1.0-SNAPSHOT.jar
    drwxr-xr-x  3 <uid>  <gid>   102 Aug 24 08:49 stale

You can ignore the "stale" directory; it has something to do with how
Leiningen works.

Now let's test the servlet.  If you've install lein-migae, do:

    ex0a $ lein migae jetty

If not, do:

    ex0a $ ./migae-jetty.sh start

Use ps to verify that it's running and inspect the error log it
creates to make sure there are no errors.

(You can stop the server with migae-jetty.sh stop or lein migae stop.)

Now send your browser to localhost:8080/test/foo.  You should get a
503 error, Service Unavailable.  In jetty.err.log you should see

    2013-08-24 10:01:19.468:WARN:oejs.Holder:main: 
    java.lang.ClassNotFoundException: ex0a.servlet

What went wrong?  First, check war/WEB-INF/web.xml to make sure we've told the servlet container to fetch the corrct servlet.  You should find:

    <servlet>
        <servlet-name>test</servlet-name>
    	<servlet-class>ex0a.servlet</servlet-class>
    </servlet>
    <servlet-mapping>
	<servlet-name>test</servlet-name>
    	<url-pattern>/test/*</url-pattern>
    </servlet-mapping>

That looks correct; now double-check that we indeed made ex0a.servlet.  That is, make sure our source tree is correct - it should have /ex0a/src/ex0a/servlet.clj, and servlet.clj should start by declaring the namespace that matches the directory layout: 

     (ns ex0a.servlet ...

In other words, ns "ex0a.servlet" must be in servlet.clj, inside
directory ex0a.  This is a Clojure requirement.

Then let's check the jarfile:

    ex0a $ tar tf war/WEB-INF/lib/ex0a-0.1.0-SNAPSHOT.jar
    META-INF/MANIFEST.MF
    META-INF/maven/ex0a/ex0a/pom.xml
    META-INF/maven/ex0a/ex0a/pom.properties
    META-INF/leiningen/ex0a/ex0a/project.clj
    project.clj
    META-INF/leiningen/ex0a/ex0a/README.md

No wonder ClassNotFound!  "lein jar" created a jarfile, but didn't put
any code in it.  Why not?  Because "lein jar" does not compile
anything; it just jars up class files (and some other stuff like the
META-INF files shown).

This would not be a problem if we were doing pure Clojure work here,
since the Clojure runtime will look for .clj files as well as class
files.  But we're using a standard Servlet container, which doesn't
know anything about Clojure.  When it receives a request for a URL
(/test/foo in this case), it looks up the URL in the web.xml file to
discover which servlet it is mapped to.  Then it searches the
classpath for the servlet, which, of course, must be a class file -
the container is only interested in Java byte code.

### gen-class and aot compilation

To fix this, we just need to compile our servlet.  The way to do this
with Leiningen is "lein compile".  To tell leiningen where the
compiled byte code should go, we use the :compile-path option in our
project file:

    :compile-path "war/WEB-INF/classes"

If you run "lein compile" as things stand, nothing will happen.
That's because Leiningen will only compile what is listed using the
:aot option in project.clj.  So uncomment what's there, yielding

    :aot [ex0a.servlet]

and run "lein compile" again.  This time you should see the class
files in war/WEB-INF/classes:

    ex0a $ ls -l war/WEB-INF/classes/ex0a/

    -rw-r--r-- gar 1010 Aug 24 11:29 servlet$_service.class
    -rw-r--r-- gar 1325 Aug 24 11:29 servlet$fn__16.class
    -rw-r--r-- gar 1878 Aug 24 11:29 servlet$loading__4910__auto__.class
    -rw-r--r-- gar 6138 Aug 24 11:29 servlet.class
    -rw-r--r-- gar 3272 Aug 24 11:29 servlet__init.class

This gives us a clue as to what gen-class does.  According to the
documentation
(http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/gen-class),
gen-class (:gen-class is the ns option corresponding to the gen-class
macro) generates bytecode for the class - in this case, the one
corresponding to the namespace of our file, i.e. ex0a.servlet.  But
the critical clause is:

    The gen-class construct contains no implementation, as the
    implementation will be dynamically sought by the generated class in
    functions in an implementing Clojure namespace.

In other words, the generated byte code will be a stub implementation
(of HttpServlet, since we used the :extends option).  Here, that means
servlet.class in the ex0a subdirectory of classes.  Now when the
container searches for ex0a.servlet it will look in the ex0a
subdirectory of the classes dir, searching for servlet.class.  On
finding it, it will load it and commence the servlet life-cycle, first
calling the init method and then the service method.

Since we did not implement the `init` method (we would have to call it
`-init`, since Clojure's convention is to prefix Java method names
with \- when using `gen-class` unless `:prefix` is used), the call to
`init` will go to the superclass.  We did implement `-service`, though,
so when the container calls the `service` method it will be handled by
the stub code generated by `gen-class`.  That code is responsible for
passing control to code that implements the Clojure function
(i.e. `-service`) defined in our source code.

Our implementation of `-service` is a pure Clojure implementation - a
function in a namespace.  For this to work, it must be converted into
a Java object.  So compilation of this code generates
`servlet$_service.class` (the \- gets converted to _), which is a
distinct java object that, when constructed, executes the
implementation code.

It is not evident from this example, but the critical element in all
this is that the `gen-class` generated stub code hooks into the Clojure
runtime.  When it comes time for the service stub to pass control to
the implementation, it is the Clojure runtime rather than the Java
runtime that will control the searching and loading.  And since our
-service implementation is in the aot-compiled namespace, it will look
for the appropriate class file.  As we will see in exercise ex1b, the
:impl-ns allows us to put our implementation in a different namespace;
the result is that Clojure will search for either a .clj file or a
.class file; if it finds the former, it will load and evaluate it.

Exercize: try deleting the .class files one at a time, and see what
kind of errors arise when you try to run the servlet.

The point of this trivial little exercise is to show how gen-class,
aot compilation, lein's jar task, and the servlet container work
together.

(The documentation on aot compilation and classes is at
http://clojure.org/compilation.)

## License

Copyright Â© 2013 FIXME

Distributed under the Eclipse Public License, the same as Clojure.
